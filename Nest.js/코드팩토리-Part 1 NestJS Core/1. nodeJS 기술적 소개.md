# nodeJS 기술적 소개

## Compiled 언어와 Iterpreted 언어

---

### Compiled 언어

- 프로그램 실행전 기계어로 전부 변환한 다음 실행
- 기계여로 모두 변환이 된 상태에서 실행되기 때문에 실행과정은 빠르다.
- 작성한 코드가 변경할 때마다 컴파일 해야하는 문제
- 타겟 플랫폼에서 직접 컴파일을 진행

### Iterpreted 언어

- 프로그램을 실행하는 도중에 각 코드를 줄별로 변환해서 실행한다.
- 모든 코드가 변환이 된 상태로 실행되지 않기 때문에 실행이 비교적 느리다.
- 코드 변경이 있을때마다 매번 전체 컴파일 할 필요가 없다.
- 코드를 실행하는 또 다른 프로그램(interpreter)가 존재한다.

---

## Just In Time Compilation(JIT)

> Compiled 언어와 Iterpreted 언어의 장점을 모아둔 형태 V8엔진 또한 JIT Compilation을 사용하고있다.

1.  코드실행 환경 준비하기
2.  컴파일 하기
3.  바이트코드 생성
4.  interpret 실행하기(바이트코드) ignition이라는 툴로
5.  컴파일 실행하기(머신코드) - 자주사용하거나 변경이 잘되지 않는 코드 최적화(터보팬)
6.  코드가 변경되거나 자주 사용하지 않는 코드들은 다시 4번으로 deoptimization(머신코드 -> 바이트코드)

---

## Byte Code vs Machine Code

### Machine Code

- cpu가 바로 읽고 사용할 수 있는 마이너리 코드 (0,1)
- 바이트코드 보다 컴퓨터에 가까운 로우레벨 코드
- 실행이 매우 빠르다
- 컴파일이 느리다
- 플랫폼에 종속성이 있다. 하나의 운영체제에서 실행 할 수 있는 기게어는 다른 운영체제에서 실행할 수 없다.

### Byte Code

- cpu가 바로 읽을 수 있는 코드가 아니다. 중간의 가상환경이나 또다른 프로그램(인터프리터)이 실행을 중재
- 머신코드보단 사람과 가까운 하이레벨 코드다
- 실행이 상대적으로 느리다.
- 컴파일이 빠르다
- 플랫폼 종속성이 없다. 인터프리터만 있으면 실행 가능

---

## nodeJS 싱글 쓰레드 모델(non-blocking)

> 쓰레드란?
> cpu에서 가용할 수 있는 인력같은 것

- 요청을 받는 Event Loop이 싱글 쓰레드
- 요청은 이벤트 큐에 하나씩 쌓임
- 싱글쓰레드인 event loop에서 이벤트 큐에 쌓인 요청을 하나씩 처리
- 요청이 non-blocking 이면 바로 빠르게 처리
- 요청이 blocking 이면 워커 쓰레드(cpu들의 스레드를 보관하고 있는 장소들?) 중 남는 쓰레드에게 보냄
- event loop은 막혀있지 않고 계속 요청을 처리
- blocking 요청이 끝나면 다시 event loop가 가져와서 response 전달

---
